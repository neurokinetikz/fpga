#!/usr/bin/env python3
"""
Generate Coupling Susceptibility LUT for v11.1a

Computes chi(r) = sum over Farey fractions { (1/q^2) * Lorentzian(r - p/q) }
                + sum over phi^n { w_phi * Lorentzian(r - phi^n) }

Output: Verilog-formatted LUT initialization for coupling_susceptibility.v
"""

import numpy as np
from math import gcd

# Constants
PHI = (1 + np.sqrt(5)) / 2  # Golden ratio = 1.618033988749895
Q14_SCALE = 16384
LORENTZ_WIDTH_RATIONAL = 0.03  # Width for rational resonances
LORENTZ_WIDTH_PHI = 0.05       # Width for phi^n boundaries
W_PHI = 0.3                    # Weight for phi^n contributions

# LUT parameters
LUT_SIZE = 256
RATIO_MIN = 0.5
RATIO_MAX = 4.5
RATIO_STEP = (RATIO_MAX - RATIO_MIN) / LUT_SIZE

def lorentzian(x, width):
    """Lorentzian function L(x) = 1 / (1 + (x/width)^2)"""
    return 1.0 / (1.0 + (x / width) ** 2)

def generate_farey_fractions(q_max, r_min, r_max):
    """Generate all reduced fractions p/q with q <= q_max in range [r_min, r_max]"""
    fractions = []
    for q in range(1, q_max + 1):
        for p in range(1, int(r_max * q) + 2):
            if gcd(p, q) == 1:  # Only coprime pairs
                r = p / q
                if r_min <= r <= r_max:
                    fractions.append((p, q, r))
    return fractions

def generate_phi_positions(n_min, n_max, r_min, r_max):
    """Generate phi^n values in range [r_min, r_max]"""
    positions = []
    for n in range(n_min, n_max + 1):
        phi_n = PHI ** n
        if r_min <= phi_n <= r_max:
            positions.append((n, phi_n))
    return positions

def compute_chi(r, farey_fractions, phi_positions):
    """
    Compute total coupling susceptibility chi(r)

    chi(r) = sum_{p,q} (1/q^2) * L(r - p/q, w_rational)
           + sum_{n} w_phi * L(r - phi^n, w_phi)
    """
    chi_rational = 0.0
    for p, q, pq in farey_fractions:
        weight = 1.0 / (q ** 2)
        chi_rational += weight * lorentzian(r - pq, LORENTZ_WIDTH_RATIONAL)

    chi_phi = 0.0
    for n, phi_n in phi_positions:
        chi_phi += W_PHI * lorentzian(r - phi_n, LORENTZ_WIDTH_PHI)

    return chi_rational + chi_phi

def main():
    print("=" * 70)
    print("Coupling Susceptibility LUT Generator - v11.1a")
    print("=" * 70)

    # Generate Farey fractions with q <= 5
    farey = generate_farey_fractions(q_max=5, r_min=0.0, r_max=5.5)
    print(f"\nFarey fractions (q <= 5): {len(farey)} total")
    for q in range(1, 6):
        fracs = [f"{p}/{q}" for p, qq, r in farey if qq == q]
        print(f"  q={q} (weight={1/q**2:.4f}): {', '.join(fracs)}")

    # Generate phi^n positions
    phi_pos = generate_phi_positions(n_min=-2, n_max=5, r_min=0.0, r_max=5.5)
    print(f"\nPhi^n positions: {len(phi_pos)} total")
    for n, phi_n in phi_pos:
        print(f"  phi^{n} = {phi_n:.4f}")

    # Compute chi values for each LUT entry
    chi_values = []
    chi_raw = []
    for i in range(LUT_SIZE):
        r = RATIO_MIN + i * RATIO_STEP
        chi = compute_chi(r, farey, phi_pos)
        chi_raw.append(chi)

    # Normalize to [0, 1] range
    chi_max = max(chi_raw)
    chi_min = min(chi_raw)
    print(f"\nRaw chi range: [{chi_min:.4f}, {chi_max:.4f}]")

    # Scale to reasonable range (0.1 to 0.98)
    for chi in chi_raw:
        # Normalize and scale
        chi_norm = (chi - chi_min) / (chi_max - chi_min)
        chi_scaled = 0.10 + 0.88 * chi_norm  # Range [0.10, 0.98]
        chi_q14 = int(round(chi_scaled * Q14_SCALE))
        chi_values.append(chi_q14)

    # Print key positions
    print("\nKey positions (ratio -> chi):")
    key_ratios = [
        (0.5, "1/2 half-int"),
        (1.0, "1/1 integer (BOUNDARY)"),
        (1.272, "phi^0.5 (ATTRACTOR)"),
        (1.5, "3/2 half-int (ATTRACTOR)"),
        (1.618, "phi^1 (BOUNDARY)"),
        (1.825, "phi^1.25 (FALLBACK)"),
        (2.0, "2/1 integer (CATASTROPHE)"),
        (2.058, "phi^1.5 (near 2:1!)"),
        (2.5, "5/2 half-int (ATTRACTOR)"),
        (2.618, "phi^2"),
        (3.0, "3/1 integer (BOUNDARY)"),
        (3.330, "phi^2.5"),
        (3.5, "7/2 half-int (ATTRACTOR)"),
        (4.0, "4/1 integer (BOUNDARY)"),
    ]

    for r, desc in key_ratios:
        idx = int((r - RATIO_MIN) / RATIO_STEP)
        if 0 <= idx < LUT_SIZE:
            chi_raw_val = chi_raw[idx]
            chi_q14_val = chi_values[idx]
            chi_decimal = chi_q14_val / Q14_SCALE
            print(f"  ratio {r:.3f} (idx {idx:3d}): chi = {chi_decimal:.3f} (Q14: {chi_q14_val:5d}) - {desc}")

    # Generate Verilog code
    print("\n" + "=" * 70)
    print("Verilog LUT Initialization Code")
    print("=" * 70)

    verilog_lines = []
    verilog_lines.append("// Coupling susceptibility LUT - v11.1a")
    verilog_lines.append("// Generated by scripts/generate_chi_lut.py")
    verilog_lines.append(f"// Formula: chi(r) = sum(1/q^2 * L(r-p/q)) + sum({W_PHI}*L(r-phi^n))")
    verilog_lines.append(f"// Lorentzian widths: rational={LORENTZ_WIDTH_RATIONAL}, phi={LORENTZ_WIDTH_PHI}")
    verilog_lines.append(f"// Farey depth: q <= 5, phi^n for n in [-2, 5]")
    verilog_lines.append("")

    # Group into lines of 8 values for readability
    verilog_lines.append("initial begin")
    for i in range(0, LUT_SIZE, 8):
        values = chi_values[i:i+8]
        ratio_start = RATIO_MIN + i * RATIO_STEP
        ratio_end = RATIO_MIN + (i+7) * RATIO_STEP
        comment = f"    // ratio {ratio_start:.3f} to {ratio_end:.3f}"
        assignments = [f"chi_lut[{i+j}] = 18'sd{values[j]};" for j in range(len(values))]
        verilog_lines.append(f"    {' '.join(assignments)}")
        verilog_lines.append(comment)
    verilog_lines.append("end")

    print("\n".join(verilog_lines))

    # Write to file
    output_file = "/Users/neurokinetikz/Code/fpga/scripts/chi_lut_values.vh"
    with open(output_file, 'w') as f:
        f.write("\n".join(verilog_lines))
    print(f"\nVerilog include file written to: {output_file}")

    # Statistical summary
    print("\n" + "=" * 70)
    print("Statistical Summary")
    print("=" * 70)

    # Count positions by category
    boundary_count = sum(1 for v in chi_values if v >= 12288)  # >= 0.75
    attractor_count = sum(1 for v in chi_values if v <= 4096)   # <= 0.25
    quarter_count = sum(1 for v in chi_values if 4096 < v <= 8192)  # 0.25-0.5

    print(f"Boundary positions (chi >= 0.75): {boundary_count} ({100*boundary_count/LUT_SIZE:.1f}%)")
    print(f"Attractor positions (chi <= 0.25): {attractor_count} ({100*attractor_count/LUT_SIZE:.1f}%)")
    print(f"Quarter-int positions (0.25 < chi <= 0.5): {quarter_count} ({100*quarter_count/LUT_SIZE:.1f}%)")
    print(f"Transition positions: {LUT_SIZE - boundary_count - attractor_count - quarter_count}")

if __name__ == "__main__":
    main()
